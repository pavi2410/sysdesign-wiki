---
title: End-to-End Encryption
tagline: Signal Protocol, key exchange, ratcheting, and encrypted storage for private communication
category: security
tags: [encryption, E2EE, Signal Protocol, cryptography, privacy]
---
import { Mermaid, ComponentList, ComponentCard, ApproachList, Approach, Example, Tradeoff } from '@/components/mdx';

## The Problem

Users expect their private messages, files, and data to be protected from everyone — including the service provider. End-to-end encryption (E2EE) ensures that only the communicating parties can read the content; the server handles encrypted blobs it cannot decrypt. Implementing E2EE requires solving key exchange (how do two parties agree on a shared secret over an insecure channel?), forward secrecy (compromising today's key shouldn't reveal past messages), multi-device synchronization (encryption keys across phone, laptop, tablet), and group encryption (efficiently encrypting for N participants). The server must be designed as an untrusted relay.

## Architectural Approaches

<ApproachList>
<Approach
  name="Signal Protocol (Double Ratchet)"
  pros={[
    "Forward secrecy — compromising one key doesn't reveal past messages",
    'Break-in recovery — new keys are generated continuously',
    'Asynchronous key exchange — works even when recipient is offline',
    'Proven security — formally verified and widely audited',
  ]}
  cons={[
    'Complex implementation — multiple layers of key derivation',
    'Key management overhead — per-device, per-conversation key pairs',
    'Multi-device support requires additional protocol extensions',
    'Cannot search encrypted content server-side',
  ]}
>
The gold standard for messaging E2EE, used by WhatsApp, Signal, and Facebook Messenger. Combines the **X3DH** key agreement protocol with the **Double Ratchet Algorithm** to provide forward secrecy and break-in recovery. Each message uses a unique encryption key derived from a constantly evolving chain.
</Approach>
<Approach
  name="MLS (Messaging Layer Security)"
  pros={[
    'Efficient group key management — O(log N) per operation',
    'IETF standard with formal specification',
    'Designed for multi-device from the ground up',
    'Better scaling for large groups than Signal Sender Keys',
  ]}
  cons={[
    'Newer protocol — less battle-tested than Signal',
    'More complex implementation than Signal Protocol',
    'Fewer library implementations available',
    'Requires a delivery service with specific ordering guarantees',
  ]}
>
IETF standard (RFC 9420) designed for **efficient group encryption**. Where Signal Protocol requires O(N) operations for N-member groups, MLS uses a tree-based key structure achieving O(log N). Designed for large groups (thousands of members) and multi-device scenarios.
</Approach>
<Approach
  name="Envelope Encryption for Data at Rest"
  pros={[
    "User controls the master key — server can't decrypt",
    'Efficient for large files — only the small DEK needs asymmetric encryption',
    'Key rotation only re-encrypts the DEK, not all data',
    'Compatible with any storage backend',
  ]}
  cons={[
    'Key loss means permanent data loss — no recovery without the master key',
    'User must manage and back up their keys',
    'No server-side search or processing of encrypted data',
    'Key derivation from password requires careful KDF design (Argon2)',
  ]}
>
For encrypting stored data (files, backups, database fields), use **envelope encryption**: encrypt data with a data encryption key (DEK), then encrypt the DEK with a key encryption key (KEK) that the user controls. The server stores the encrypted DEK alongside the encrypted data but never has the plaintext KEK.
</Approach>
</ApproachList>

## Architecture

<Mermaid chart={`graph TB
    subgraph ClientA["Client A (Sender)"]
        A_APP[App Logic]
        A_CRYPTO[Crypto Engine]
        A_KEYS[Key Store - Local / Secure Enclave]
    end
    subgraph Server["Server (Untrusted Relay)"]
        KS[Key Distribution Service]
        MSG[Message Relay]
        STORE[(Encrypted Message Store)]
        PKS[(Pre-Key Store)]
    end
    subgraph ClientB["Client B (Recipient)"]
        B_APP[App Logic]
        B_CRYPTO[Crypto Engine]
        B_KEYS[Key Store - Local / Secure Enclave]
    end
    A_APP --> A_CRYPTO
    A_CRYPTO --> A_KEYS
    A_CRYPTO -->|Encrypted message| MSG
    A_CRYPTO -->|Fetch pre-keys| KS
    KS --> PKS
    MSG --> STORE
    STORE --> MSG
    MSG -->|Encrypted message| B_CRYPTO
    B_CRYPTO --> B_KEYS
    B_CRYPTO --> B_APP
    B_CRYPTO -->|Upload pre-keys| KS`} caption="End-to-End Encryption — High-level architecture" />

## Key Components

<ComponentList>
<ComponentCard name="Crypto Engine (Client-Side)">
Library running on the client that handles all cryptographic operations: key generation, X3DH key agreement, Double Ratchet message encryption/decryption, and session management. Must use constant-time operations to prevent timing attacks. Implementations: libsignal (C/Rust), olm/vodozemac (Matrix).
</ComponentCard>
<ComponentCard name="Key Distribution Service">
Server-side component that stores and distributes public pre-keys. When Alice wants to message Bob for the first time, she fetches Bob's pre-key bundle (identity key, signed pre-key, one-time pre-keys) from this service. The server never sees private keys.
</ComponentCard>
<ComponentCard name="Pre-Key Store">
Database of per-device public keys uploaded by clients. Stores identity keys (long-term), signed pre-keys (medium-term, rotated monthly), and one-time pre-keys (single-use, replenished in batches). One-time pre-keys are deleted after distribution to ensure forward secrecy.
</ComponentCard>
<ComponentCard name="Message Relay">
Routes encrypted message blobs between clients. The server sees: sender ID, recipient ID, timestamp, and an opaque encrypted payload. It cannot read the content. Stores messages for offline recipients and delivers when they connect.
</ComponentCard>
<ComponentCard name="Local Key Store">
Secure client-side storage for private keys and session state. Uses the OS secure enclave (iOS Keychain, Android Keystore) or encrypted local storage. Keys never leave the device. Lost device = lost keys (new device requires re-establishing sessions).
</ComponentCard>
<ComponentCard name="Safety Number / Key Verification">
Mechanism for users to verify each other's identity keys out-of-band (QR code scan, number comparison). Detects man-in-the-middle attacks where the server substitutes its own keys. Signal and WhatsApp show "safety numbers" for this purpose.
</ComponentCard>
</ComponentList>

## Data Model

<Mermaid chart={`erDiagram
    DEVICE {
        string device_id PK
        string user_id FK
        string identity_public_key
        string signed_pre_key
        string signed_pre_key_signature
        timestamp signed_pre_key_uploaded_at
    }
    ONE_TIME_PRE_KEY {
        string key_id PK
        string device_id FK
        string public_key
        boolean used
        timestamp uploaded_at
    }
    ENCRYPTED_MESSAGE {
        string message_id PK
        string sender_device_id FK
        string recipient_device_id FK
        bytes ciphertext
        bytes ephemeral_key
        int message_number
        timestamp created_at
        boolean delivered
    }
    SESSION_STATE {
        string session_id PK
        string local_device_id
        string remote_device_id
        bytes serialized_state
        timestamp updated_at
    }
    DEVICE ||--o{ ONE_TIME_PRE_KEY : uploads
    DEVICE ||--o{ ENCRYPTED_MESSAGE : sends
    DEVICE ||--o{ ENCRYPTED_MESSAGE : receives`} caption="End-to-End Encryption — Entity relationship diagram" />

## X3DH Key Agreement

The **Extended Triple Diffie-Hellman** (X3DH) protocol establishes a shared secret between two parties, even when one is offline.

**Key types per user**:
- **Identity Key (IK)**: Long-term key pair, generated once per device
- **Signed Pre-Key (SPK)**: Medium-term key pair, rotated monthly, signed by IK
- **One-Time Pre-Key (OPK)**: Single-use key pair, uploaded in batches of 100

**Protocol flow** (Alice initiates session with offline Bob):
1. Alice fetches Bob's pre-key bundle from the server: IK_B, SPK_B, OPK_B
2. Alice generates an ephemeral key pair: EK_A
3. Alice computes four DH exchanges:
   - DH1 = DH(IK_A, SPK_B)
   - DH2 = DH(EK_A, IK_B)
   - DH3 = DH(EK_A, SPK_B)
   - DH4 = DH(EK_A, OPK_B) — optional, provides forward secrecy
4. Shared secret = KDF(DH1 || DH2 || DH3 || DH4)
5. Alice sends her initial message with IK_A and EK_A public keys
6. Bob computes the same DH exchanges on his side to derive the same shared secret

The one-time pre-key (OPK) is deleted after use, ensuring that even if long-term keys are compromised later, this specific session key cannot be derived retroactively.

<Mermaid chart={`sequenceDiagram
    participant A as Alice
    participant S as Server
    participant B as Bob
    Note over B,S: Bob uploads pre-keys while online
    B->>S: Upload IK_B, SPK_B, OPK_B[1..100]
    Note over A: Alice wants to message offline Bob
    A->>S: Request Bob's pre-key bundle
    S->>A: IK_B, SPK_B, OPK_B[1]
    Note over S: Delete OPK_B[1] (single-use)
    Note over A: Compute X3DH shared secret
    A->>A: Generate ephemeral key EK_A
    A->>A: DH1..DH4 → shared secret
    A->>A: Encrypt first message
    A->>S: Send {IK_A, EK_A, encrypted_msg}
    Note over B: Bob comes online
    S->>B: Deliver {IK_A, EK_A, encrypted_msg}
    B->>B: Compute X3DH shared secret
    B->>B: Decrypt first message`} caption="X3DH Key Agreement Flow" />

## Double Ratchet Algorithm

After X3DH establishes the initial shared secret, the **Double Ratchet** provides ongoing forward secrecy and break-in recovery.

**Two ratchets**:
1. **Symmetric ratchet (chain key)**: After each message, the chain key is ratcheted forward using a KDF: `chain_key[n+1] = KDF(chain_key[n])`. Each message gets a unique message key derived from the chain. Old chain keys are deleted, providing forward secrecy.
2. **Asymmetric ratchet (DH ratchet)**: On each message exchange, both parties generate new DH key pairs and perform a new DH exchange. This "ratchets" the root key forward, providing break-in recovery — even if an attacker compromises the current state, future messages are safe once a new DH exchange occurs.

**Combined operation**: Every message from Alice includes a new public DH key. When Bob sends a reply, he performs a DH with Alice's latest key, advancing the root ratchet. Both parties maintain sending and receiving chains that ratchet forward with each message.

**Key deletion**: The critical security property. After deriving a message key, delete it. After advancing the chain, delete the old chain key. This means a compromised device can only decrypt the current message, not past ones.

**Out-of-order messages**: The Double Ratchet handles out-of-order delivery by caching skipped message keys (within limits). If message #5 arrives before #4, the key for #4 is stored temporarily so it can be decrypted when it arrives.

## Group Encryption Challenges

Encrypting for a group of N members is fundamentally harder than 1:1 encryption.

**Naive approach**: Encrypt the message separately for each member using their pairwise session. Cost: O(N) encryptions per message. Fine for small groups (&lt;50) but impractical for large groups.

**Sender Keys (Signal's approach for groups)**: Each member generates a "sender key" and distributes it to all group members via pairwise encrypted channels. Messages are encrypted once with the sender key, and all members can decrypt. Cost: O(1) encryption per message, O(N) for sender key distribution.

**Limitations of Sender Keys**:
- Adding a member requires distributing all existing sender keys
- Removing a member requires ALL members to generate new sender keys (the removed member knows the old keys)
- No forward secrecy within the group — compromising a sender key reveals all past group messages encrypted with it

**MLS (tree-based)**: Uses a binary tree structure where each member is a leaf. The group secret is at the root. Adding/removing a member requires updating O(log N) nodes in the tree. Much more efficient for large groups and provides better forward secrecy guarantees than Sender Keys.

## Real-World Examples

<Example system="Signal">
Created the Signal Protocol — the reference implementation. Open-source client and server. Uses X3DH + Double Ratchet for 1:1, Sender Keys for groups. Sealed sender feature hides even the sender's identity from the server.
</Example>

<Example system="WhatsApp">
Deployed Signal Protocol to 2B+ users. E2EE for all messages, calls, and media. Media is encrypted client-side and uploaded to a CDN; only the encryption key is sent via the encrypted message channel. Multi-device support via linked devices.
</Example>

<Example system="Matrix/Element">
Uses the Olm (1:1) and Megolm (group) protocols, inspired by Signal Protocol but adapted for Matrix's federated architecture. Room keys are shared via Olm sessions. Supports cross-signing for device verification.
</Example>

<Example system="iMessage">
Apple's proprietary E2EE for messages. Each device has its own encryption key pair registered with Apple's Identity Service. Messages are encrypted per-device for each recipient. Does not use Signal Protocol — custom protocol based on AES-CTR and ECDSA.
</Example>

## Architectural Tradeoffs

<Tradeoff
  decision="Signal Protocol vs simpler encryption (AES with shared key)"
  pros={['Signal: forward secrecy, break-in recovery, proven security', 'Simple AES: much easier to implement, lower complexity', 'Signal: asynchronous key exchange works for offline users']}
  cons={['Signal: complex implementation, many moving parts', 'Simple AES: no forward secrecy — one key compromise reveals everything', 'Signal: requires pre-key server infrastructure and session management']}
/>

<Tradeoff
  decision="Server-side vs client-side key management"
  pros={['Server-side (key escrow): enables recovery, server-side search', "Client-side: true zero-knowledge, server can't access data", 'Client-side: regulatory compliance for sensitive data']}
  cons={['Server-side: not true E2EE — provider can access data', 'Client-side: key loss = permanent data loss', 'Client-side: no server-side features (search, analytics, moderation)']}
/>

<Tradeoff
  decision="Sender Keys vs MLS for group encryption"
  pros={['Sender Keys: simpler, O(1) encryption per message', 'MLS: O(log N) member changes, better forward secrecy', 'Sender Keys: proven in production (WhatsApp groups of 1024)']}
  cons={['Sender Keys: O(N) cost for member changes, weak forward secrecy', 'MLS: newer, less battle-tested, more complex', 'MLS: requires ordered message delivery from the server']}
/>
